---
layout: post
title: "使用php实现一个简单的server——TCP篇"
description: ""
category: 
tags: [php,网络编程，服务器]
---
{% include JB/setup %}


## 使用PHP实现一个简单的服务器 ##

<img src="tcp.png" alt="xxxxxx" style="width:600px;"/>

### 背景 ###

关于背景知识上一篇已经阐述清楚了，这一篇主要基于TCP的方式来进行通信设计的php服务器。

### 基本原理 ###


主要原理：

服务层主要包括一个分发用户请求的进程和多个工作进程。分发进程和工作进程之间的通信方式主要通过内核提供的消息队列模式。工作进程处理好后将结果写到另外一个消息队列类别中去。然后由主进程从该消息队列类别中取出处理结果返回给用户。


-消息格式

因为是TCP的通信方式，发包和接收包的时候，都不是完整的接收客户端send函数一次发送的数据，可能会分多次发送过来。这样就给消息的接收端带来了麻烦。所以消息格式的设计就显得尤为重要。我们在要发送消息的首部放置了消息的数据部分的总长度，这样接收方会先接收到这个长度，从而根据这个长度分一次或者多次来接收剩下的整体数据包。从而解决了上述的问题。UDP是整包发，整包接收的，所以就不需要做这种处理了。

-任务分发主进程
	
   主进程还是做接入使用，采用select接入模型。将需要监听的套接字放到监听读数组中去，调用select函数进行遍历查看是否有数据请求，然后for循环遍历读套接字数组，进行数据接收，这里在接收数据的时候，就会根据接收包的长度来分多次接收数据直到接收完整的数据包，然后才将请求发送到消息队列。然后再从另外一个消息队列中去获取处理结果，并将结果返回。

-工作进程


该进程就是不间断的从合适的消息队列中选择一个任务出来进行处理，然后将结果进行写到另一个队列中去。



### 几个小问题 ###




- 就是TCP是面向流模式的，所以在发包接收包，可能会出现多个小包组合在一起发出去，或者一个比较大的包会拆分为多个小包。而udp是面向数据报的模式，所以是整包发，整包接，但是在ip层也会被拆包，但是在接收方组包，如果这里组包成功，然后接收端就可以直接完整拿到对方发的整个包。如果这里组包失败，那么则直接丢弃，所以UDP的包不能太大。不然降低网络效率。
- TCP的粘包问题，本文的解决方案就是在包头防止包的整体长度。但是这样不是最好的办法。

有问题联系xxzapple@126.com